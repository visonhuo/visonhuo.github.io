---
title: "微服务架构中的消息通信方式"
date: 2022-02-20T15:50:53+08:00
lastmod: 2022-02-20T15:50:53+08:00
draft: true
author: visonhuo
description: "文章将讨论在微服务架构中进程间通信的交互模式，并基于消息队列介绍这些交互模式的工作过程、应用场景。"
featuredImage: "/images/feature/architecture_design/message_pattern_bg.png"
featuredImagePreview: "/images/feature/architecture_design/message_pattern_bg.png"
categories: ["架构设计"]
tags: ["微服务", "进程间通信", "消息队列"]
---
<!--more-->

## 前言
在微服务架构中，RPC、消息队列是我们常用的进程间通信方式。
也正是因为这两种方式过于普及，导致我们很容易忽略作为通信过程中的其他交互方式。

在这篇文章中，我们将会介绍进程间通信在微服务架构中的几种交互模式，
并基于消息队列来讲述几种交互模式的工作过程及其应用场景。
将会讨论如下主题：
- [x] 进程间通信的交互模式
- [x] 五种消息交互模式
- [x] 命令消息 or 事件消息

## 进程间通信的交互模式
当谈到进程间通信时，也许大多数人的第一反应就是 **RPC（Remote Procedure Call）** ，
因为确实 RPC 是最符合我们直观感受上的进程间通信。其工作过程为：
1. Consumer 传递请求消息给到 Provider ；
2. Provider 收到请求，执行相关逻辑；
3. Provider 处理完毕，回复消息给到 Consumer；

{{< mermaid >}}
graph LR;
A[Consumer] --> |request| B[Provider]
B --> |reply| A
{{< /mermaid >}}

进程间通信简单来讲就是消息的传递，而消息传递的过程必然存在两个角色：**生产端** 和 **消费端** 。
如果我们不去关注消息底层究竟是如何进行传递的，那在这个过程中，我们只需要考虑如下三个维度：
- 消费端是否需要回复消息？
- 生产端是否需要等待回复消息？（同步 or 异步）
- 消息是发送给一个，还是多个消费者端？（一对一 or 一对多）

通过组合以上三个维度就可以得出以下这几种进程间通信的交互方式。
|    |**一对一**|**一对多**｜
|:------:|:------:|:-------:|
|**同步模式**|同步请求/响应| 广播请求/响应 |
|**异步模式**|异步请求/响应（有回复） <br /> 单向通知（无回复） | 发布/订阅（无回复）|

如果使用 RPC 来套用套用上述的三个维度：
- RPC 中消费端（对应 Provider）需要回复消息；
- RPC 中生产端（对应 Consumer）需要等待回复消息；
- RPC 中消息仅发送给一个消费者端；
所以，RPC 本身属于 **同步请求/响应模式** 的范畴。

那么消息队列属于什么模式呢？严格来说，消息队列只提供了消息传递的能力，并不从属于具体的交互模式。
所以，可以由我们自己来定义生产端与消费端的行为，从而实现以上列举的所有交互模式。

接下来，我们将基于消息队列来逐个介绍一下以上列举的几种交互方式。

## 五种消息交互模式
### 同步请求/响应
{{< image src="https://i.bmp.ovh/imgs/2022/02/3590de50989105f5.png" caption="同步请求 + 一对一消费" >}}

这种便是典型的 RPC 工作模式。通过消息队列我们同样可以实现 RPC 的工作方式，其中的关键点在于：
1. 生产端发送请求消息时，需要在消息中携带 **回复队列 + 请求消息ID** 的信息；
2. 消费端处理消息完毕后，将消息发往请求中指定的 **回复队列** ，并携带 **请求消息ID** 的信息；
3. 生产端监听指定的 **回复队列** ，并在收到回复消息后，通过 **请求消息ID** 将回复与请求进行关联；

虽然通过文件表述这个过程十分简单，但如果要将这套方案应用在生产环境中需要考虑很多细节。
在本人之前的工作经历中，确实存在某些部门是通过消息队列来实现 **同步请求/响应模式** 的。

相比于 RPC 方案，这种方式的好处在于：
- **统一组件** : 不需要单独维护另一套 RPC 方案，通过消息队列能满足多种交互模式；
- **通信可用性高** : 生产端和消费者端不一定需要同时都在线，可以允许短暂的节点失效；

而该方案的缺点则在于：
- **热点组件** : 消息队列承担了所有进程间通信的职责，需要组件本身具备高性能、高可用的特性；
- **消息延迟** : 因为所有的请求消息、回复消息都需要经过 MQ 才能传递到对端，所以一次请求的端到端延迟自然比直连的 RPC 通信高得多，尤其需要考虑当队列负载很高时的情况。

{{< admonition type=tip title="代理型消息队列 or 无代理消息队列" open=open >}}
开源的 MQ 实现其实有很多，其中基于是否需要部署独立消息队列进程，可以分为如下两种类型。
- **代理型消息队列** : 需要部署独立的消息队列组件，所有的消息需要由队列进程进行传递。典型代表有 Kafka、RabbitMQ 等；
- **无代理消息队列** : 不需要独立的消息队列组件，通过 Library 或者协议的方式工作，消息是在生产端和消费端之间直接传递。典型代表有 ZeroMQ 等；

通常我们都会使用代理型消息队列组件，所以本文中所有关于交互模式的介绍都是基于代理型消息队列组件，
包括其优缺点的讨论。

此处需要注意 **代理型MQ** 和 **无代理MQ** 的工作机制是不同的，比如消息延迟高的缺点，
在无代理消息队列中并不是一个问题，它们是点对点直连的。
{{< /admonition >}}

### 异步请求/响应
{{< image src="https://i.bmp.ovh/imgs/2022/02/333118465657d72e.png" caption="异步请求 + 一对一消费" >}}

在 **异步请求/响应** 的模式下，工作流程如下：
1. 生产端发送请求消息到 MQ 之后，便会接着执行后续的逻辑，不会阻塞等待响应；
2. 消费端处理完请求消息后，将结果信息回复到指定的 **回复队列** 中；
3. 生产端监听 **回复队列** ，在另一条线程（不同于发送请求的线程）中执行结果处理逻辑；

该模式比较适合：**执行耗时，并存在结果状态需要传递的场景**。 

举个例子，用户请求服务端进行视频转码，这类任务通常执行时间较长，不可能让客户端同步等待执行结果。
所以我们通常的做法是：
1. Server 接收到请求后，生成一个 **taskID** ，并将其与相关数据封装成请求消息传递给 transcode service；
2. Server 将第一步生成的 **taskID** 返回给客户端；
3. 提供一个查询的 API 给客户端，通过 **taskID** 能够查询任务的执行状态；
4. 当 transcode service 处理完成后，回复相关的结果响应数据给回 Server ；
5. Server 收到结果响应数据后，更新 **taskID**对应记录的状态以及记录结果相关数据；

{{< admonition type=warning title="假设成立么？" open=open >}}
在 **异步请求/响应模式** 中，如果一切工作良好，则 Server 会正常收到所有任务的处理结果响应。
但如果 transcode service 没有正常返回执行结果信息呢（如宕机、超时、网络中断等情况）？
客户端查询到的任务状态可能会一直卡在 'processing' 状态，这是不正确的。

所以当使用该模式时，我们一定要考虑 **兜底策略** ，比如给任务状态设置一个超时，设置定时任务去定期检查状态等手段。
**总之，无论使用什么模式，我们都需要考虑流程异常的情况。**
{{< /admonition >}}

### 单向通知
{{< image src="https://i.bmp.ovh/imgs/2022/02/8394c2ed4d818851.png" caption="异步请求 + 一对一消费 + 无回复" >}}

典型的异步消息场景，生产端将消息发送给消费者之后，便执行后续的逻辑，完全不关心执行情况。
该模式比较适用于 **简单的，对失败容忍程度较高的业务场景**。

比如邮件通知服务，在部分流程中（如用户注册后的欢迎邮件等），邮件漏发并不会导致非常严重的问题，
所以请求发送邮件的 Server 并不需要关心邮件发送的执行结果，只需要把消息正常的投递出去即可。

### 发布/订阅
{{< image src="https://i.bmp.ovh/imgs/2022/02/25237412749d186f.png" caption="异步请求 + 一对多消费 + 无回复" >}}

与 **单向通知模式** 十分相似，区别在于该模式是 **一对多消费** 。
但其实这并不是这两种模式本质上的区别，同样是一个生产端，同样是发送消息到队列，
为什么 **单向通知模式** 只能有一个消费者，而发布/订阅模式可以存在多个消费者呢？

究其原因是在于 **消息类型不同**，单向通知模式使用的是命令消息，发布/订阅模式使用的是事件消息。
而关于命令消息和事件消息的区别，我们会在后面的小节再来介绍。

**发布/订阅模式** 适用于领域事件通知的场景，比如新用户注册、用户下单等事件，
当业务中存在某些服务需要依赖这些事件时，便可以考虑使用发布/订阅模式。

### 同步请求/多响应
{{< image src="https://i.bmp.ovh/imgs/2022/02/19421bf07726ee54.png" caption="同步请求 + 一对多消费 + 多回复" >}}

该模式相对比较特殊，它属于是 **同步请求/响应模式** 的一种拓展，即我们可以从多个消费端来收集数据。

日常我们使用 RPC 时，我们只需要从服务提供者列表中的某一个节点上获取数据即可，
这种情况是建立在 **所有的节点共享一个数据视图的情况下** 。
如果每个服务节点存在不同的数据视图，则普通的 RPC 模式将显得力不从心。

举个例子，分布式缓存（Redis）和本地缓存的区别：
- **分布式缓存** : 无论请求哪一个服务节点，获取的数据都是一致的；
- **本地缓存** : 缓存数据放置在不同节点上，同一个 key 在不同节点上，其值可能并不相同；

假设我们现在需要检查每个节点的本地缓存视图是否一致，使用单纯的 RPC 便无法完成目标了。
此时我们便可以考虑 **同步请求/多响应模式**，通过使用消息队列支持一对多消费的能力，来实现此类场景的功能。

## 命令消息和事件消息
在发布/订阅模式小节，我们指出了其与单向通知模式的区别在于：**消息类型的不同**。
并指出了两种消息类型：**命令消息** 与 **事件消息**，以下是关于两者的描述。
- **命令消息（Command）**: 一条等同于 RPC 请求的消息，需要指定要调用的操作及其参数；
- **事件消息（Event）**: 表示发送方这一端发生了重要的事件（通常是领域事件），表示领域对象的状态更改；

以上的定义可能还是有些晦涩，其实简单来说，两种类型的区别在于 **消息体的语义**。

举个例子：新用户创建时，Server 需要对其发送通知邮件。
创建过程发生在用户服务，所以用户服务需要发送一条消息通知邮件服务发送欢迎邮件。

此时我们就面临一个设计决策，**使用 Command 还是 Event ？** 两者产生的效果是完全不同的。

如果我们使用 **Command**，那么消息体就会长这个样子。
```json
{
  "id": 101,
  "email": "vison@gmail.com",
  "content": "Hi vison, welcome to here..."
}
```
在用户服务中，我们需要按照邮件服务的请求格式来组装消息。
由于消息组装的逻辑放在了请求测中，**邮件服务则不需要考虑上游的业务逻辑，作为底层基础服务它将更通用**。

<br />

如果我们使用 **Event**，那么消息体就变成如下内容。
```json
{
  "user_id": 101,
  "user_email": "vison@gmail.com",
  "user_name": "vison",
  "create_time": 16023903432
}
```
在用户服务中，它只关心将领域对象（此处对应用户对象）的 **源数据信息** 广播出去，它并不关心其他服务如何处理这些信息，
因此 **该消息没有与任何其他业务耦合，消息体更加通用**，可以被多个消费者端使用，
这便是为什么 **发布/订阅模式** 需要使用 Event 类型的消息。

但在这个场景中，作为邮件服务，它便要处理适配的逻辑，需要处理这些源数据信息，将其适配成对应的邮件内容来进行邮件发送。
从某种程度来说，便 **破坏了邮件服务作为底层基础服务的通用性**。

{{< admonition type=question title="为什么消息类型很重要？" open=open >}}
如上所述，**消息类型决定了消息的交互方式，甚至业务职责划分等问题**。
所以当我们在系统中设计消息相关的交互场景时，需要更加细致地考虑类型这个问题。
{{< /admonition >}}

## 小结
在这篇文章中，我们介绍了 **进程间通信的交互模式**，
并基于消息队列来讲述每种交互模式是如何工作的，以及其适用的场景，
最后简单介绍了 **Command** 和 **Event** 消息的区别。

异步消息是我们日常开发中常用的手段，虽然我们熟悉它的使用，但不免也容易忽略使用背后应有的考量。
在开发实践中，我们应该多去关注那些我们认为理所应当的事情，多问自己几个问题，多看看别人是如何思考这些问题的，
也许能从中发现更加广阔的天地，**即要着眼于细节，也要时不时抬起身俯瞰全貌**。

## Reference
- [《Microservices Pattern》(Chris Richardson)](https://microservices.io/index.html)